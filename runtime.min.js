(function(){"use strict";const FSG_NAMESPACE="https://rintaroutw.github.io/fsg",SNAP_GRID_INTERVAL=5,COMPONENT_NO_ATTR="component_no",COMPONENT_REFS_ATTR="component_refs",OF_ATTR="of",VECTOR_START_MARKER_RADIUS=3,VECTOR_END_MARKER_ARROW_WIDTH=6,VECTOR_END_MARKER_ARROW_LENGTH=10,POINT_RADIUS=6,DEFAULT_TEXT=String.raw`\LaTeX`,DEFAULT_LABEL_OFFSET_X=5,DEFAULT_LABEL_OFFSET_Y=5,DEFAULT_FILL_COLOR="#ff0f6328",DEFAULT_STROKE_COLOR="#888888aa";function init_component(e){e.fsg.component={};const t=e.find(".component");let n=0;t.forEach((e=>{const t=Number(e.attr(COMPONENT_NO_ATTR));t>n&&(n=t)})),e.fsg.component.max_component_no=n,e.fsg.component.allComponents=[]}function componentByNo(e,t){const n=e.fsg.component.allComponents.find((e=>e.component_no==Number(t)));return console.assert(n,"component not found",t),n}function labelOf(e,t){const n=e.find(".label");let o=null;return n.each((e=>{t==Number(e.attr(OF_ATTR))&&(o=e)})),o}class Component{constructor({draw:e,element:t}){console.assert(e,"draw is required"),console.assert(t,"element is required"),e.add(t),this.draw=e,this.element=t,t.component=this;void 0===t.attr(COMPONENT_NO_ATTR)&&(e.fsg.component.max_component_no++,t.attr(COMPONENT_NO_ATTR,e.fsg.component.max_component_no)),this.component_no=Number(t.attr(COMPONENT_NO_ATTR));const n=t.attr("label");n&&this.addLabel(e,n),t.on("mouseenter",(()=>{e.dragTarget||e.dragSelectStart||t.addClass("hover")})).on("mouseleave",(()=>{t.removeClass("hover")})),selectComponent(this.draw,this),e.fsg.component.allComponents.push(this)}tracePoints(e,t){e.forEach((e=>{e.on("update",(e=>{t(e)}))}))}remove(){this.removeLabel(),unselectComponent(this.draw,this),this.element.fire("remove"),this.element.remove(),this.draw.fsg.component.allComponents=this.draw.fsg.component.allComponents.filter((e=>e!==this))}center(){return{x:this.element.cx(),y:this.element.cy()}}forward(){this.element.forward()}backward(){this.element.backward()}back(){this.draw.findOne(".fsg-board").after(this.element)}front(){this.element.front()}undo(){this.remove()}select(){this.element.addClass("selected")}unselect(){this.element.removeClass("selected"),this.element.removeClass("hover")}toggleSelected(){this.element.hasClass("selected")?unselectComponent(this.draw,this):selectComponent(this.draw,this)}getAttributes(){return["id","class","cx","cy","text","fill","stroke"]}getAttribute(e){return"text"==e?this.getText():this.element.attr(e)}setAttribute(e,t){if("text"==e)return e="label",this.element.attr(e,t),void this.setText(t);this.element.attr(e,t)}setText(e){e&&0!=e.length?this.label?this.label.text(e):this.addLabel(e):this.removeLabel()}getText(){return this.label?this.label.text():""}addLabel(e){const t=this.draw,n=this.element;let o=labelOf(t,this.component_no);if(!o){const r={x:n.cx()+DEFAULT_LABEL_OFFSET_X,y:-n.cy()+DEFAULT_LABEL_OFFSET_Y};o=t.text(e).attr("class","label").attr("offset_x",DEFAULT_LABEL_OFFSET_X).attr("offset_y",DEFAULT_LABEL_OFFSET_Y).attr(OF_ATTR,n.attr(COMPONENT_NO_ATTR)).flip("y").move(r.x,r.y),t.add(o)}o.on("mousedown",(e=>{o.lastEvent="mousedown",o.fire("dragstart",{dragTarget:o}),e.stopPropagation()})).on("mouseup",(()=>{o.lastEvent="mouseup",o.fire("dragend")})).on("mousemove",(()=>{o.lastEvent="mousemove"})).on("dragstart",(()=>{t.dragTarget=o})).on("dragend",(()=>{t.dragTarget=null;const e={dx:o.x()-n.cx(),dy:o.y()+n.cy()};o.attr("offset_x",e.dx).attr("offset_y",e.dy)})),this.tracePoints([n],(()=>{const e=o.attr("offset_x"),t=o.attr("offset_y"),r={x:n.cx()+e,y:-n.cy()+t};o.move(r.x,r.y)}));const r=new MutationObserver((e=>{e.forEach((e=>{if("label"==e.attributeName){let e=n.node.getAttribute("label");e||(e="");const t=o.attr("offset_x"),r=o.attr("offset_y");console.log(t,r);const s={x:n.cx()+t,y:-n.cy()+r};o.text(e).move(s.x,s.y)}}))}));r.observe(n.node,{attributes:!0}),this.observer=r,this.label=o}removeLabel(){this.label&&(this.observer.disconnect(),this.observer=null,this.label.remove(),this.label=null)}}function init_marker(e){deinit_marker(e),e.fsg.marker={};let t=e.defs().findOne(".vector-start-marker");t||(t=e.marker(2*VECTOR_START_MARKER_RADIUS,2*VECTOR_START_MARKER_RADIUS,(e=>{const t=VECTOR_START_MARKER_RADIUS;e.circle(t).radius(t).cx(t).cy(t).attr("class","vector-marker-start")})).attr("class","vector-start-marker")),e.fsg.marker.vector_start_marker=t;let n=e.defs().findOne(".vector-end-marker");n||(n=e.marker(VECTOR_END_MARKER_ARROW_LENGTH,VECTOR_END_MARKER_ARROW_WIDTH,(e=>{e.polygon(`0 0, ${VECTOR_END_MARKER_ARROW_LENGTH} ${VECTOR_END_MARKER_ARROW_WIDTH/2} , 0 ${VECTOR_END_MARKER_ARROW_WIDTH}`).stroke({width:1}).attr("class","vector-marker-end")})).size(VECTOR_END_MARKER_ARROW_LENGTH,VECTOR_END_MARKER_ARROW_WIDTH).ref(VECTOR_END_MARKER_ARROW_LENGTH,VECTOR_END_MARKER_ARROW_WIDTH/2).attr("class","vector-end-marker")),e.fsg.marker.vector_end_marker=n}function deinit_marker(e){e.fsg.marker?.vector_start_marker&&(e.fsg.marker.vector_start_marker.remove(),e.fsg.marker.vector_start_marker=null),e.fsg.marker?.vector_end_marker&&(e.fsg.marker.vector_end_marker.remove(),e.fsg.marker.vector_end_marker=null)}function snapTo(e){return{x:e.x-=e.x%SNAP_GRID_INTERVAL,y:e.y-=e.y%SNAP_GRID_INTERVAL}}const tolerance_error=1e-4;function inside(e,t){return t&&t.x>=e.x-tolerance_error&&t.x<=e.x+e.width+tolerance_error&&t.y>=e.y-tolerance_error&&t.y<=e.y+e.height+tolerance_error}function pointOnScreen(e){const t=e.element,n=t.cx(),o=t.cy(),r=t.transform();return{x:n*r.a+o*r.c+r.e,y:n*r.b+o*r.d+r.f}}function clipping(e,t,n){console.assert(t,"p1 is required"),console.assert(n,"p2 is required");const o={x:n.x-t.x,y:n.y-t.y},{x:r,y:s,width:i,height:a}=e;let c=[],l={x:1,y:0},d=intersect(t,o,n={x:r,y:s},l);return inside(e,d)&&c.push(d),l={x:0,y:1},d&&d.x==r||(d=intersect(t,o,n,l),inside(e,d)&&c.push(d)),d=intersect(t,o,n={x:r+i,y:s+a},l),inside(e,d)&&c.push(d),l={x:1,y:0},d&&d.y==s+i||(d=intersect(t,o,n,l),inside(e,d)&&c.push(d)),c}function intersect(e,t,n,o){let r=t.x*o.y-o.x*t.y;if(0==r)return null;let s=((n.x-e.x)*o.y-(n.y-e.y)*o.x)/r;return{x:e.x+s*t.x,y:e.y+s*t.y}}function projectPointOnLine(e,t,n){const o=e.x-t.x,r=e.y-t.y,s=o*n.x+r*n.y;return{x:t.x+n.x*s,y:t.y+n.y*s}}function intersectLineAndCircle(e,t,n,o){console.assert(o,"circleRadius must be defined");const r=projectPointOnLine(n,e,t),s=(n.x-r.x)**2+(n.y-r.y)**2;if(s>o**2)return null;if(s==o**2)return[r];const i=Math.sqrt(o**2-s);return[{x:r.x+t.x*i,y:r.y+t.y*i},{x:r.x-t.x*i,y:r.y-t.y*i}]}function twoCirclesIntersection(e,t){var n,o,r,s,i,a,c=Math.sqrt((e.a-t.a)**2+(e.b-t.b)**2);if(e.r+t.r>=c&&c>=Math.abs(e.r-t.r)){var l=c+e.r+t.r,d=c+e.r-t.r,m=c-e.r+t.r,p=-c+e.r+t.r,u=Math.sqrt(l*d*m*p)/4;if(r=(n=(e.a+t.a)/2+(t.a-e.a)*(e.r*e.r-t.r*t.r)/(2*c*c))+(o=2*(e.b-t.b)*u/(c*c)),s=n-o,i=(n=(e.b+t.b)/2+(t.b-e.b)*(e.r*e.r-t.r*t.r)/(2*c*c))-(o=2*(e.a-t.a)*u/(c*c)),a=n+o,Math.abs((r-e.a)*(r-e.a)+(i-e.b)*(i-e.b)-e.r*e.r)>1e-7){var f=i;i=a,a=f}return[{x:r,y:i},{x:s,y:a}]}return null}class AppendingPinPoint{constructor({draw:e,componentRef:t,element:n}){this.element=n,n.component=this,e.dragTarget=n,n.on("dragmove",(()=>{n.fire("update",{target:this})}));const o=componentByNo(e,t);console.assert(o,"cant find target compoenent",t),o.element.on("update",this.update.bind(this)),o.element.on("remove",this.remove.bind(this)),this.draw=e,this.targetComponent=o,o.element.hasClass("circle")?this.type="circle":this.type="line"}remove(){this.targetComponent.element.off("update",this.update),this.targetComponent.element.off("remove",this.remove),this.element.remove()}done(){console.log("done");const e=this.draw,t=this.type,n={x:this.element.cx(),y:this.element.cy()},o=this.targetComponent.component_no;return this.remove(),{draw:e,coord:n,type:t,componentRef:o}}update(){if("line"==this.type){const e=this.targetComponent,t=projectPointOnLine(this.draw.mousePosition,e.startPoint(),e.direction());this.element.center(t.x,t.y)}else{const e=this.targetComponent.element,t=this.targetComponent.radius;if(0==t)return;const n={x:e.cx(),y:e.cy()},o={x:this.draw.mousePosition.x-n.x,y:this.draw.mousePosition.y-n.y},r=t/Math.sqrt(o.x**2+o.y**2),s={x:n.x+o.x*r,y:n.y+o.y*r};this.element.center(s.x,s.y)}}}function addAppendingPinPoint({draw:e,componentRef:t}){console.assert(t,"componentRef must be defined");const n=e.circle(POINT_RADIUS).move(e.mousePosition.x-POINT_RADIUS/2,e.mousePosition.y-POINT_RADIUS/2).attr("class","pin-point dragging");return new AppendingPinPoint({draw:e,componentRef:t,element:n})}function findBottom(e,t){let n=t[0];return t.forEach((t=>{const o=e.index(t);-1!=o&&o<e.index(n)&&(n=t)})),n}class ShapeComponent extends Component{constructor({draw:e,element:t,cover:n,points:o}){console.assert(e,"draw is required"),console.assert(t,"element is required"),console.assert(n,"cover is required"),console.assert(o,"points is required"),super({draw:e,element:t});const r=o.map((e=>e.attr(COMPONENT_NO_ATTR)));r.join(",").length>1&&t.attr(COMPONENT_REFS_ATTR,r.join(",")),this.points=o,n.attr(OF_ATTR,this.component_no).attr("fill",DEFAULT_FILL_COLOR),this.cover=n;const s=findBottom(e,o);e.index(s)>0&&(n.insertBefore(s),t.insertBefore(n));const i=e=>{this.toggleSelected(),e.stopPropagation()};n.on("mousedown",i).on("mouseenter",(()=>{e.dragTarget||e.dragSelectStart||(t.addClass("hover"),n.addClass("hover"))})).on("mouseleave",(()=>{t.removeClass("hover"),n.removeClass("hover")})),t.on("mousedown",i)}remove(){this.cover.remove(),super.remove()}}class FillableShape extends ShapeComponent{constructor({draw:e,element:t,cover:n,points:o,isHiddenPoint:r}){super({draw:e,element:t,cover:n,points:o,isHiddenPoint:r})}}class LineBaseShape extends ShapeComponent{constructor({draw:e,element:t,cover:n,points:o,isHiddenPoint:r}){super({draw:e,element:t,cover:n,points:o,isHiddenPoint:r}),this.isAppending=null,r||this.tracePoints(o,(()=>{t.fire("update")}))}startPoint(){const e=this.points[0];let t={x:e.cx(),y:e.cy()};return e.component&&(t=pointOnScreen(e.component)),t}direction(){const[e,t]=this.points;let n={x:e.cx(),y:e.cy()},o={x:t.cx(),y:t.cy()};e.component&&t.component&&(n=pointOnScreen(e.component),o=pointOnScreen(t.component));const r=o.x-n.x,s=o.y-n.y,i=Math.sqrt(r**2+s**2);return{x:r/i,y:s/i}}endAppendMode(){this.isAppending&&(this.isAppending.remove(),this.isAppending=null)}toggleAppendMode(e){if(this.isAppending)this.endAppendMode();else{const t=this.component_no;this.isAppending=addAppendingPinPoint({draw:e,componentRef:t})}}getAttributes(){return["id","class","cx","cy","text","stroke"]}}function currentFillColor(){return SVG("#field_fill").node.value}function currentStrokeColor(){return SVG("#field_stroke").node.value}function setStyle(e){const t=currentStrokeColor();e.attr("stroke",t)}class UnSelectablePoint extends Component{constructor({draw:e,element:t}){super({draw:e,element:t}),unselectComponent(e,this)}getAttributes(){return console.assert(!0,"unselectable point should not be inspected"),[]}}class SelectablePoint extends Component{constructor({draw:e,element:t,override:n}){n||t.on("mousedown",(e=>{t.lastEvent="mousedown",e.stopPropagation()})).on("mouseup",(()=>{"mousedown"==t.lastEvent&&this.toggleSelected(),t.lastEvent="mouseup"})),super({draw:e,element:t})}getAttributes(){return["id","class","cx","cy","text"]}}class DraggablePoint extends SelectablePoint{constructor({draw:e,element:t,override:n}){n||(t.on("mousedown",(e=>{t.lastEvent="mousedown",t.fire("dragstart",{dragTarget:t}),e.stopPropagation()})).on("mouseup",(()=>{"mousedown"==t.lastEvent&&this.toggleSelected(),t.lastEvent="mouseup",t.fire("dragend")})).on("mousemove",(()=>{t.lastEvent="mousemove"})).on("dragstart",(()=>{t.addClass("dragging"),e.dragTarget=t})).on("dragend",(()=>{t.removeClass("dragging"),e.dragTarget=null})).on("dragmove",(()=>{t.fire("update",{target:this})})),n=!0),super({draw:e,element:t,override:n})}}class Point extends DraggablePoint{constructor({draw:e,element:t}){super({draw:e,element:t})}}function addPoint({draw:e,coord:t,element:n,component_no:o}){return t||(t={x:0,y:0}),n||setStyle(n=e.circle(POINT_RADIUS).move(t.x-POINT_RADIUS/2,t.y-POINT_RADIUS/2).attr("class","point component")),o&&n.attr(COMPONENT_NO_ATTR,o),new Point({draw:e,coord:t,element:n,component_no:o})}class IntersectPoint extends SelectablePoint{constructor({draw:e,index:t,componentRefs:n,element:o}){super({draw:e,element:o}),this.index=t,console.assert(void 0!==t,"index should be defined"),o.attr(COMPONENT_REFS_ATTR,n.join(","));const r=n.map((t=>componentByNo(e,t)));this.refComponents=r,r.forEach((e=>{e.element.on("update",this.update.bind(this)),e.element.on("remove",this.remove.bind(this))}))}remove(){this.refComponents.forEach((e=>{e.element.off("update",this.update)})),super.remove()}update(){const e=this.refComponents;if(console.assert(e),e[1]instanceof SelectablePoint){const[t,n]=e,o=projectPointOnLine(pointOnScreen(n),t.startPoint(),t.direction());return this.element.center(o.x,o.y),void this.element.fire("update")}if(e[0]instanceof LineBaseShape)if(e[1]instanceof LineBaseShape){const[t,n]=e,o=intersect(t.startPoint(),t.direction(),n.startPoint(),n.direction());if(!o)return;this.element.center(o.x,o.y)}else{const[t,n]=e,o=intersectLineAndCircle(t.startPoint(),t.direction(),n.center(),n.radius);if(console.assert(o,"intersect point must be defined",o),!o)return;const r=o[this.index];r?this.element.center(r.x,r.y):console.log(this.index)}else if(e[1]instanceof LineBaseShape){const[t,n]=e,o=intersectLineAndCircle(n.startPoint(),n.direction(),t.center(),t.radius);if(!o)return;const r=o[this.index];this.element.center(r.x,r.y)}else{const[t,n]=e,o=twoCirclesIntersection({a:t.center().x,b:t.center().y,r:t.radius},{a:n.center().x,b:n.center().y,r:n.radius});if(!o)return;const r=o[this.index];this.element.center(r.x,r.y)}this.element.fire("update")}}function addIntersectPoint({draw:e,coord:t,index:n,componentRefs:o,element:r,component_no:s}){return t||(t={x:0,y:0}),r?(n=r.attr("index"),console.assert(void 0!==n,"index must be defined")):(console.assert(void 0!==n,"index must be defined"),r=e.circle(POINT_RADIUS).move(t.x-POINT_RADIUS/2,t.y-POINT_RADIUS/2).attr("class","intersect-point component").attr("index",n)),s&&r.attr(COMPONENT_NO_ATTR,s),new IntersectPoint({draw:e,index:n,componentRefs:o,element:r})}class ParallelPoint extends UnSelectablePoint{constructor({draw:e,componentRefs:t,element:n}){super({draw:e,element:n}),n.attr(COMPONENT_REFS_ATTR,t.join(","));const o=t.map((t=>componentByNo(e,t)));this.refComponents=o,o.forEach((e=>{e.element.on("update",this.update.bind(this)),e.element.on("remove",this.remove.bind(this))}))}remove(){this.refComponents.forEach((e=>{e.element.off("update",this.update)})),super.remove()}update(){const[e,t]=this.refComponents,n=t.center(),o=e.direction(),r={x:n.x+20*o.x,y:n.y+20*o.y};this.element.center(r.x,r.y),this.element.fire("update")}}function addParallelPoint({draw:e,coord:t,componentRefs:n,element:o,component_no:r}){return o||(o=e.circle(POINT_RADIUS).move(t.x-POINT_RADIUS/2,t.y-POINT_RADIUS/2).attr("class","parallel-point component")),r&&o.attr(COMPONENT_NO_ATTR,r),new ParallelPoint({draw:e,componentRefs:n,element:o})}class PerpPoint extends UnSelectablePoint{constructor({draw:e,componentRefs:t,element:n}){super({draw:e,element:n}),n.attr(COMPONENT_REFS_ATTR,t.join(","));const o=t.map((t=>componentByNo(e,t)));this.refComponents=o,o.forEach((e=>{e.element.on("update",this.update.bind(this)),e.element.on("remove",this.remove.bind(this))}))}remove(){this.refComponents.forEach((e=>{e.element.off("update",this.update)})),super.remove()}update(){const[e,t]=this.refComponents,n=e.direction(),o=pointOnScreen(t),r={x:o.x-20*n.y,y:o.y+20*n.x};this.element.center(r.x,r.y),this.element.fire("update")}}function addPerpPoint({draw:e,coord:t,componentRefs:n,element:o,component_no:r}){return o||(o=e.circle(POINT_RADIUS).move(t.x-POINT_RADIUS/2,t.y-POINT_RADIUS/2).attr("class","perp-point component")),r&&o.attr(COMPONENT_NO_ATTR,r),new PerpPoint({draw:e,componentRefs:n,element:o})}class PinPoint extends DraggablePoint{constructor({draw:e,type:t,componentRef:n,element:o}){super({draw:e,element:o,override:!0}),this.type=t,o.attr(COMPONENT_REFS_ATTR,n),o.on("mousedown",(e=>{o.lastEvent="mousedown",o.fire("dragstart",{dragTarget:o}),e.stopPropagation()})).on("mouseup",(()=>{"mousedown"==o.lastEvent&&this.toggleSelected(),o.lastEvent="mouseup",o.fire("dragend")})).on("mousemove",(()=>{o.lastEvent="mousemove"})).on("dragstart",(()=>{o.addClass("dragging"),e.dragTarget=o})).on("dragend",(()=>{o.removeClass("dragging"),this.calcState(),e.dragTarget=null})).on("dragmove",(()=>{o.fire("update",{target:this})}));const r=componentByNo(e,n);r.element.on("update",this.update.bind(this)),r.element.on("remove",this.remove.bind(this)),this.targetComponent=r,this.calcState()}remove(){this.targetComponent.element.off("update",this.update),super.remove()}calcState(){const e=this.element;if("line"==this.type){const t=this.targetComponent,n=t.startPoint(),o=t.direction(),r=e.cx()-n.x,s=e.cy()-n.y;this.distance=0!=r?r/o.x:0!=s?s/o.y:0}else{const t=this.targetComponent,n=t.radius;if(0==n)this.unitVector={x:0,y:0};else{const o={x:t.element.cx(),y:t.element.cy()},r={x:e.cx(),y:e.cy()};this.unitVector={x:(r.x-o.x)/n,y:(r.y-o.y)/n}}}}update(){if(this.draw.dragTarget!=this.element){if("line"==this.type){const e=this.targetComponent,t=e.startPoint(),n=e.direction(),o={x:t.x+n.x*this.distance,y:t.y+n.y*this.distance};this.element.center(o.x,o.y)}else{const e=this.targetComponent,t=e.element,n=e.radius;if(0==n)return;const o={x:t.cx(),y:t.cy()},r=this.unitVector,s={x:o.x+r.x*n,y:o.y+r.y*n};this.element.center(s.x,s.y)}this.element.fire("update")}else{if("line"==this.type){const e=this.targetComponent,t=projectPointOnLine(this.draw.mousePosition,e.startPoint(),e.direction());this.element.center(t.x,t.y)}else{const e=this.targetComponent.element,t=this.targetComponent.radius;if(0==t)return;const n={x:e.cx(),y:e.cy()},o={x:this.draw.mousePosition.x-n.x,y:this.draw.mousePosition.y-n.y},r=t/Math.sqrt(o.x**2+o.y**2),s={x:n.x+o.x*r,y:n.y+o.y*r};this.element.center(s.x,s.y)}this.element.fire("update")}}}function addPinPoint({draw:e,coord:t,type:n,componentRef:o,element:r,component_no:s}){return r||(r=e.circle(POINT_RADIUS).move(t.x-POINT_RADIUS/2,t.y-POINT_RADIUS/2).attr("class","pin-point component")),s&&r.attr(COMPONENT_NO_ATTR,s),new PinPoint({draw:e,type:n,componentRef:o,element:r})}class Text extends Component{constructor({draw:e,element:t}){super({draw:e,element:t}),this.makeDraggable(e,t)}makeDraggable(e,t){t.on("mousedown",(e=>{t.lastEvent="mousedown",t.fire("dragstart",{dragTarget:t}),e.stopPropagation()})).on("mouseup",(()=>{"mousedown"==t.lastEvent&&this.toggleSelected(),t.lastEvent="mouseup",t.fire("dragend")})).on("mousemove",(()=>{t.lastEvent="mousemove"})).on("dragstart",(()=>{t.addClass("dragging"),e.dragTarget=t})).on("dragend",(()=>{t.removeClass("dragging"),e.dragTarget=null})).on("dragmove",(()=>{t.fire("update",{target:this})}))}setText(e){e||(e="");let t=this.element;const n=this.draw,o={x:t.attr("x"),y:-t.attr("y")};t.clear().remove(),t=genText(this.draw,e,o),t.component=this,this.makeDraggable(n,t),n.add(t),this.element=t}getText(){return this.element.attr("text")}getAttributes(){return["id","class","cx","cy","text"]}}function foreignTex(e,t){const n=SVG(String.raw`<div class="latex-container">$${t}$</div>`);let o;try{renderMathInElement(n.node,katex_options),o=e.foreignObject(500,200).add(n);const{width:t,height:r}=n.node.getBoundingClientRect();return o.size(t,r),o}catch(e){return console.log(e),o&&o.remove(),null}}function genText(e,t,n){return foreignTex(e,t).flip("y").attr("class","text selected component").attr("text",t).attr("x",n.x).attr("y",-n.y)}function addText({draw:e,element:t,text:n,unselect:o}){if(!t){const o=e.mousePosition;t=genText(e,n=n??DEFAULT_TEXT,o)}const r=new Text({draw:e,element:t});return o&&unselectComponent(e,r),r}const katex_options={throwOnError:!1,output:"html",delimiters:[{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0},{left:"\\begin{equation}",right:"\\end{equation}",display:!0}],trust:!0,strict:"ignore",macros:{"\\eqref":"\\href{#1}{}","\\label":"\\href{#1}{}","\\require":"\\href{#1}{}","\\tag":"\\href{#1}{}","\\hfil":"\\space","\\style":"\\href{#1}{}","\\def":"\\gdef","\\cal":"\\mathcal","\\pmatrix":"\\begin{pmatrix}#1\\end{pmatrix}","\\vmatrix":"\\begin{vmatrix}#1\\end{vmatrix}","\\bmatrix":"\\begin{bmatrix}#1\\end{bmatrix}","\\cases":"\\begin{cases}#1\\end{cases}","\\align":"\\begin{aligned}#1\\end{aligned}","\\eqalign":"\\begin{aligned}#1\\end{aligned}","\\array":"\\begin{array}#1\\end{array}","\\gather":"\\begin{gathered}#1\\end{gathered}"}};function init_history(e){e.fsg.history={},e.fsg.history.history=[],e.fsg.history.redo_list=[]}function doAction(e,t,n){const o=e.fsg.history,r=t(n);r.redo=()=>{r.component_no&&(n.component_no=r.component_no),doAction(e,t,n)},o.history.push(r)}function init_drag(e,t=!0){let n;const o=e.findOne(".ui-select-box");o?n=o:(n=e.rect(0,0).attr("class","ui-select-box"),e.add(n)),e.selectBox=n,e.dragTarget=null,e.dragStart=null,e.on("mousedown",(t=>{if(e.dragTarget&&e.dragTarget.component instanceof AppendingPinPoint){const t=e.dragTarget.component.done();doAction(e,addPinPoint,t)}else e.lastEvent="mousedown";t.altKey||(e.dragStart=e.point(t.clientX,t.clientY)),e.dragTarget=null})).on("mouseup_on_document",(()=>{e.dragTarget&&(e.dragTarget.fire("dragend"),e.dragTarget=null),e.dragStart&&(e.dragStart=null,n.size(0,0))})).on("mouseup",(o=>{if(e.dragTarget&&(e.dragTarget.fire("dragend"),e.dragTarget=null),e.dragStart=null,n.size(0,0),"mousedown"==e.lastEvent&&(e.lastEvent="mouseup",t)){let t=e.point(o.clientX,o.clientY);t=snapTo(t),doAction(e,addPoint,{draw:e,coord:t})}})).on("mousemove",(t=>{e.lastEvent="mousemove";const o=e.point(t.clientX,t.clientY);e.mousePosition=snapTo(o);const r=e.dragTarget;if(r)if(r.component instanceof AppendingPinPoint||r.component instanceof PinPoint)r.component.update();else{const e={x:r.cx(),y:r.cy()},t=o;t.x==e.x&&t.y==e.y||("text"==r.type||r.component instanceof Text?r.center(t.x,-t.y):r.center(t.x,t.y),r.fire("dragmove"))}if(e.dragStart){let r=Math.abs(o.x-e.dragStart.x),s=Math.abs(o.y-e.dragStart.y),i=(o.x+e.dragStart.x)/2,a=(o.y+e.dragStart.y)/2;n.size(r,s).center(i,a),selectAllInBox(e,n,t.shiftKey)}}))}function selectAllInBox(e,t,n){e.find(".component").forEach((o=>{if(!n&&o.hasClass("selected"))return;const r=o.bbox();t.inside(r.x,r.y)&&t.inside(r.x+r.width,r.y+r.height)&&(console.assert(o.component,"element.component must exist",o),n?unselectComponent(e,o.component):selectComponent(e,o.component))}))}class Circle extends FillableShape{constructor({draw:e,radius:t,points:n,element:o,cover:r}){super({draw:e,element:o,cover:r,points:n}),this.radius=t;const[s,i]=n;this.tracePoints(n,(()=>{const e=Math.sqrt((i.cx()-s.cx())**2+(i.cy()-s.cy())**2);this.radius=e,o.radius(e),o.center(s.cx(),s.cy()),r.radius(e),r.center(s.cx(),s.cy()),this.label&&this.label.move(o.cx(),-o.cy()),o.fire("update")}))}endAppendMode(){this.isAppending&&(this.isAppending.remove(),this.isAppending=null)}toggleAppendMode(e){if(this.isAppending)this.endAppendMode();else{const t=this.component_no;this.isAppending=addAppendingPinPoint({draw:e,componentRef:t})}}}function addCircle({draw:e,componentRefs:t,element:n,cover:o,component_no:r}){const s=t.map((t=>componentByNo(e,t).element)),[i,a]=s,c=Math.sqrt((a.cx()-i.cx())**2+(a.cy()-i.cy())**2);if(!n){if(n=e.circle().radius(c).center(i.cx(),i.cy()).attr("class","circle dashed shape component selected none"),window.FSG){const e=currentFillColor(),t=currentStrokeColor();n.attr("fill",e),n.attr("stroke",t)}o=e.circle().radius(c).center(i.cx(),i.cy()).attr("class","cover")}return r&&n.attr(COMPONENT_NO_ATTR,r),new Circle({draw:e,radius:c,points:s,element:n,cover:o,component_no:r})}class Polygon extends FillableShape{constructor({draw:e,points:t,element:n,cover:o}){super({draw:e,element:n,cover:o,points:t}),this.tracePoints(t,(()=>{let e=t.map((e=>{const t=pointOnScreen(e.component);return[t.x,t.y]}));n.plot(e),o.plot(e),this.label&&this.label.move(n.cx(),-n.cy())}))}}function addPolygon({draw:e,componentRefs:t,element:n,cover:o,component_no:r}){const s=t.map((t=>componentByNo(e,t).element)),i=s.map((e=>[e.cx(),e.cy()]));if(!n){if(n=e.polygon(i).attr("class","polygon dashed shape component selected none"),window.FSG){const e=currentFillColor(),t=currentStrokeColor();n.attr("fill",e),n.attr("stroke",t)}o=e.polygon(i).attr("class","cover")}return r&&n.attr(COMPONENT_NO_ATTR,r),new Polygon({draw:e,points:s,element:n,cover:o})}function init_selection(e){console.assert(e,"draw must exist"),e.fsg.selection={},e.fsg.selection.selections=[],window.selectComponent=selectComponent$1,window.unselectComponent=unselectComponent$1}const inspector=SVG("#inspector");function inspect(e){inspector?.fire("inspect-component",{component:e})}function detach(){inspector?.fire("inspect-detach")}function selectComponent$1(e,t){if(!e.ready)return;console.assert(e,"draw must exist");let n=e.fsg.selection.selections,o=Array.isArray(t)?t:[t];return o.forEach((e=>{console.assert(e,o),e.select(),n=n.filter((t=>t!==e)),n.push(e),inspect(e)})),e.fsg.selection.selections=n,t}function unselectComponent$1(e,t){console.assert(e,"draw must exist");let n=e.fsg.selection.selections;(Array.isArray(t)?t:[t]).forEach((e=>{e.unselect(),n=n.filter((t=>t!==e))}));const o=n.length;return 0==o?detach():inspect(n[o-1]),e.fsg.selection.selections=n,t}function setStrokeColor(e){if(window.FSG){const t=currentStrokeColor();e.attr("stroke",t)}}class LineSegment extends LineBaseShape{constructor({draw:e,points:t,element:n,cover:o,isHiddenPoint:r}){if(super({draw:e,element:n,cover:o,points:t,isHiddenPoint:r}),r)unselectComponent(e,this);else{const[e,r]=t;this.tracePoints(t,(()=>{const t=pointOnScreen(e.component),s=pointOnScreen(r.component);n.plot(t.x,t.y,s.x,s.y),o.plot(t.x,t.y,s.x,s.y),this.label?.move(n.cx(),-n.cy())}))}}}function addEdge({draw:e,componentRefs:t,element:n,cover:o,component_no:r}){const s=t.map((t=>componentByNo(e,t).element));if(!n){const[t,r]=s,i={x:t.cx(),y:t.cy()},a={x:r.cx(),y:r.cy()};setStrokeColor(n=e.line(i.x,i.y,a.x,a.y).attr("class","edge dashed shape component selected")),o=e.line(i.x,i.y,a.x,a.y).attr("class","cover")}return r&&n.attr(COMPONENT_NO_ATTR,r),new LineSegment({draw:e,points:s,element:n,cover:o})}function addVector({draw:e,componentRefs:t,element:n,cover:o,component_no:r}){const s=t.map((t=>componentByNo(e,t).element));if(!n){const[t,r]=s,i={x:t.cx(),y:t.cy()},a={x:r.cx(),y:r.cy()};setStrokeColor(n=e.line(i.x,i.y,a.x,a.y).attr("class","vector dashed shape component selected")),o=e.line(i.x,i.y,a.x,a.y).attr("class","cover")}return n.marker("start",e.fsg.marker.vector_start_marker),n.marker("end",e.fsg.marker.vector_end_marker),r&&n.attr(COMPONENT_NO_ATTR,r),new LineSegment({draw:e,points:s,element:n,cover:o})}function addAxis({draw:e,type:t,element:n,cover:o,component_no:r}){const s=e.findOne("#"+t+"-start"),i=e.findOne("#"+t+"-end");console.assert(s,"axis start point is required"),console.assert(i,"axis end point is required");const a=[s,i];if(!n){const[r,s]=a,i={x:r.cx(),y:r.cy()},c={x:s.cx(),y:s.cy()};n=e.line(i.x,i.y,c.x,c.y).attr("class",t+" dashed shape component selected").attr("stroke",DEFAULT_STROKE_COLOR),o=e.line(i.x,i.y,c.x,c.y).attr("class","cover")}return n.marker("end",e.fsg.marker.vector_end_marker),n.removeClass("dashed"),n.addClass(t),r&&n.attr(COMPONENT_NO_ATTR,r),new LineSegment({draw:e,points:a,element:n,cover:o,isHiddenPoint:!0})}class Line extends LineBaseShape{constructor({draw:e,points:t,element:n,cover:o}){super({draw:e,element:n,cover:o,points:t});const[r,s]=t;this.tracePoints(t,(()=>{const t=e.bbox(),i=pointOnScreen(r.component),a=pointOnScreen(s.component),[c,l]=clipping(t,i,a);c&&l&&(n.plot(c.x,c.y,l.x,l.y),o.plot(c.x,c.y,l.x,l.y),this.label&&this.label.move(n.cx(),-n.cy()))}))}}function addLine({draw:e,componentRefs:t,element:n,cover:o,component_no:r}){const s=t.map((t=>componentByNo(e,t).element));if(!n){const t=e.bbox(),[r,i]=s;console.assert(r,"p1 must be defined",s),console.assert(i,"p2 must be defined",s);const a={x:r.cx(),y:r.cy()},c={x:i.cx(),y:i.cy()},[l,d]=clipping(t,a,c);setStrokeColor(n=e.line(l.x,l.y,d.x,d.y).attr("class","line dashed shape component selected")),o=e.line(l.x,l.y,d.x,d.y).attr("class","cover")}return r&&n.attr(COMPONENT_NO_ATTR,r),new Line({draw:e,points:s,element:n,cover:o,component_no:r})}function getClipped(e,t,n){console.assert(t,"p1 must be defined"),console.assert(n,"p2 must be defined");const o=e.bbox();console.log(o);const[r,s]=clipping(o,{x:t.x,y:t.y},{x:n.x,y:n.y});console.assert(r,"clip1 must be defined"),console.assert(s,"clip2 must be defined");const i=n.x-t.x,a=n.y-t.y,c=r.x-t.x,l=r.y-t.y;let d=r;return 0!=i?c*i<0&&(d=s):l*a<0&&(d=s),d}class Ray extends LineBaseShape{constructor({draw:e,points:t,element:n,cover:o}){super({draw:e,element:n,cover:o,points:t});const[r,s]=t;this.tracePoints(t,(()=>{const t=pointOnScreen(r.component),i=pointOnScreen(s.component),a=getClipped(e,t,i);n.plot(t.x,t.y,a.x,a.y),o.plot(t.x,t.y,a.x,a.y),this.label&&this.label.move(n.cx(),-n.cy())}))}}function addRay({draw:e,componentRefs:t,element:n,cover:o,component_no:r}){const s=t.map((t=>componentByNo(e,t).element));if(!n){const[t,r]=s,i={x:t.cx(),y:t.cy()},a={x:r.cx(),y:r.cy()},c=getClipped(e,i,a);setStrokeColor(n=e.line(i.x,i.y,c.x,c.y).attr("class","ray dashed shape component selected")),o=e.line(i.x,i.y,c.x,c.y).attr("class","cover")}return r&&n.attr(COMPONENT_NO_ATTR,r),new Ray({draw:e,points:s,element:n,cover:o})}class ParallelLine extends Line{constructor({draw:e,points:t,element:n,cover:o}){super({draw:e,element:n,cover:o,points:t});const r=t.map((e=>(e.on("remove",this.remove.bind(this)),e.attr("component_no"))));n.attr(COMPONENT_REFS_ATTR,r.join(","))}undo(){this.points[1].remove(),super.undo()}}function addParallelLine({draw:e,coord:t,componentRefs:n,element:o,cover:r,component_no:s}){let i=n.map((t=>componentByNo(e,t).element));if(!o){const s=i[1],a=addParallelPoint({draw:e,coord:t,componentRefs:n}).element,c=e.bbox();console.assert(s,"p1 must be defined",i),console.assert(a,"p2 must be defined",i);const l={x:s.cx(),y:s.cy()},d={x:a.cx(),y:a.cy()},[m,p]=clipping(c,l,d);setStrokeColor(o=e.line(m.x,m.y,p.x,p.y).attr("class","parallel-line dashed shape component selected")),r=e.line(m.x,m.y,p.x,p.y).attr("class","cover"),i=[s,a]}return s&&o.attr(COMPONENT_NO_ATTR,s),new ParallelLine({draw:e,points:i,element:o,cover:r,component_no:s})}function findAllComponentElements(e){const t=e.find(".component");return t.sort(((e,t)=>Number(e.attr(COMPONENT_NO_ATTR))-Number(t.attr(COMPONENT_NO_ATTR)))),t}function elementByNo(e,t){let n;return e.forEach((e=>{Number(e.attr(COMPONENT_NO_ATTR))==t&&(n=e)})),n}function reconstruct_components(e){const t=e.find(".cover"),n=findAllComponentElements(e);n.forEach((o=>{if(o.hasClass("point"))return void addPoint({draw:e,element:o});if(o.hasClass("intersect-point")){const t=o.attr(COMPONENT_REFS_ATTR);if(!t)return;const n=t.split(",").map((e=>Number(e)));return void addIntersectPoint({draw:e,componentRefs:n,element:o})}if(o.hasClass("parallel-point")){const t=o.attr(COMPONENT_REFS_ATTR);if(!t)return;const n=t.split(",").map((e=>Number(e)));return void addParallelPoint({draw:e,componentRefs:n,element:o})}if(o.hasClass("perp-point")){const t=o.attr(COMPONENT_REFS_ATTR);if(!t)return;const n=t.split(",").map((e=>Number(e)));return void addPerpPoint({draw:e,componentRefs:n,element:o})}if(o.hasClass("pin-point")){const t=o.attr(COMPONENT_REFS_ATTR);if(!t)return;const r=elementByNo(n,t);console.assert(r,"failed to locate the refereneced element");let s="line";return r instanceof SVG.Circle&&(s="circle"),void addPinPoint({draw:e,type:s,componentRef:t,element:o})}if(o.hasClass("text")&&addText({draw:e,element:o}),o.hasClass("axis-x")){const n=coverOf(t,o.attr(COMPONENT_NO_ATTR));return void addAxis({draw:e,type:"axis-x",element:o,cover:n})}if(o.hasClass("axis-y")){const n=coverOf(t,o.attr(COMPONENT_NO_ATTR));return void addAxis({draw:e,type:"axis-y",element:o,cover:n})}const r=o.attr(COMPONENT_REFS_ATTR);if(!r)return;const s=r.split(",").map((e=>Number(e))),i=coverOf(t,o.attr(COMPONENT_NO_ATTR));o.hasClass("edge")?addEdge({draw:e,componentRefs:s,element:o,cover:i}):o.hasClass("vector")?addVector({draw:e,componentRefs:s,element:o,cover:i}):o.hasClass("line")?addLine({draw:e,componentRefs:s,element:o,cover:i}):o.hasClass("ray")?addRay({draw:e,componentRefs:s,element:o,cover:i}):o.hasClass("polygon")?addPolygon({draw:e,componentRefs:s,element:o,cover:i}):o.hasClass("circle")?addCircle({draw:e,componentRefs:s,element:o,cover:i}):o.hasClass("parallel-line")?addParallelLine({draw:e,componentRefs:s,element:o,cover:i}):console.log("WARNNING: unsupported component..",o)}))}function coverOf(e,t){let n=null;return e.forEach((e=>{t==e.attr(OF_ATTR)&&(n=e)})),console.assert(n,"cover is required",e,t),n}function init_modules(e){e.fsg={},init_history(e),init_selection(e),init_marker(e),init_component(e),init_drag(e,!1),reconstruct_components(e)}function execute_script_in_file(){const scripts=document.querySelectorAll("script");scripts.forEach((script=>{script.getAttribute("xmlns")==FSG_NAMESPACE&&eval(script.textContent)}))}function init(){if(window.FSG)console.log("runtime should not be run under editor");else{if(window.FSG_RUNTIME)return;window.FSG_RUNTIME=!0;if(document.contentType.includes("html")){const e=document.querySelectorAll("svg");e.forEach((e=>{SVG(e).attr("xmlns:fsg")})),e.forEach((e=>{init_modules(SVG(e).first())}))}else{const e=SVG("svg").first();init_modules(e),e.ready=!0,execute_script_in_file()}}}SVG.on(document,"DOMContentLoaded",(()=>init()))})();